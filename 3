#начало программы
#иницализируем граф
#создаем пустой массив ответ
#dfs(u)
#   берем какую то вершину u
#   помечаем ее как посещенную
#   запускаем функцию dfs от смежной непосещенной вершины
#   когда возвращаемся к этой вершине добовляем ее в массив ответ
#перебираем все вершины если вершина не посещенна то запускаем dfs
#переворачиваем массив ответ
#конец программы

n = 10
m = 7
g = [[] for _ in range(n)]
for _ in range(m):
    v, u = map(int, input().split())
    g[v].append(u)
used = [False] * n
l = []
def dfs(v):
    used[v] = True
    for u in g[v]:
        if not used[u]:
            dfs(u)
    l.append(v)
for i in range(n):
    if not used[i]:
        dfs(i)
l.reverse()
print(*l)
